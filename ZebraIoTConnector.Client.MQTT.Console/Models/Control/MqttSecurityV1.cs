/*
 * RAW MQTT Payloads
 *
 *  
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// Configuration of MQTT Security
    /// </summary>
    [DataContract]
    public partial class MqttSecurityV1 : IEquatable<MqttSecurityV1>
    { 
        /// <summary>
        /// Format for the CA Certificate and Public and Private Keys
        /// </summary>
        /// <value>Format for the CA Certificate and Public and Private Keys</value>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum KeyFormatEnum
        {
            /// <summary>
            /// Enum PEMEnum for PEM
            /// </summary>
            [EnumMember(Value = "PEM")]
            PEMEnum = 0        }

        /// <summary>
        /// Format for the CA Certificate and Public and Private Keys
        /// </summary>
        /// <value>Format for the CA Certificate and Public and Private Keys</value>
        [Required]

        [DataMember(Name="keyFormat")]
        public KeyFormatEnum? KeyFormat { get; set; }

        /// <summary>
        /// Algorithm used for the CA Certificate and Public and Private Keys
        /// </summary>
        /// <value>Algorithm used for the CA Certificate and Public and Private Keys</value>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum KeyAlgorithmEnum
        {
            /// <summary>
            /// Enum RSA256Enum for RSA256
            /// </summary>
            [EnumMember(Value = "RSA256")]
            RSA256Enum = 0        }

        /// <summary>
        /// Algorithm used for the CA Certificate and Public and Private Keys
        /// </summary>
        /// <value>Algorithm used for the CA Certificate and Public and Private Keys</value>
        [Required]

        [DataMember(Name="keyAlgorithm")]
        public KeyAlgorithmEnum? KeyAlgorithm { get; set; }

        /// <summary>
        /// Path and file name of the CA Certificate
        /// </summary>
        /// <value>Path and file name of the CA Certificate</value>
        [Required]

        [DataMember(Name="CACertificateFileLocation")]
        public string CACertificateFileLocation { get; set; }

        /// <summary>
        /// Path and file name of the Public Key
        /// </summary>
        /// <value>Path and file name of the Public Key</value>
        [Required]

        [DataMember(Name="publicKeyFileLocation")]
        public string PublicKeyFileLocation { get; set; }

        /// <summary>
        /// Path and file name of the Private Key
        /// </summary>
        /// <value>Path and file name of the Private Key</value>
        [Required]

        [DataMember(Name="privateKeyFileLocation")]
        public string PrivateKeyFileLocation { get; set; }

        /// <summary>
        /// check that the server certificate hostname matches the remote. Using this option means that you cannot be sure that the remote host is the server you wish to connect to and so is insecure.
        /// </summary>
        /// <value>check that the server certificate hostname matches the remote. Using this option means that you cannot be sure that the remote host is the server you wish to connect to and so is insecure.</value>
        [Required]

        [DataMember(Name="verifyHostName")]
        public bool? VerifyHostName { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class MqttSecurityV1 {\n");
            sb.Append("  KeyFormat: ").Append(KeyFormat).Append("\n");
            sb.Append("  KeyAlgorithm: ").Append(KeyAlgorithm).Append("\n");
            sb.Append("  CACertificateFileLocation: ").Append(CACertificateFileLocation).Append("\n");
            sb.Append("  PublicKeyFileLocation: ").Append(PublicKeyFileLocation).Append("\n");
            sb.Append("  PrivateKeyFileLocation: ").Append(PrivateKeyFileLocation).Append("\n");
            sb.Append("  VerifyHostName: ").Append(VerifyHostName).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((MqttSecurityV1)obj);
        }

        /// <summary>
        /// Returns true if MqttSecurityV1 instances are equal
        /// </summary>
        /// <param name="other">Instance of MqttSecurityV1 to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MqttSecurityV1 other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    KeyFormat == other.KeyFormat ||
                    KeyFormat != null &&
                    KeyFormat.Equals(other.KeyFormat)
                ) && 
                (
                    KeyAlgorithm == other.KeyAlgorithm ||
                    KeyAlgorithm != null &&
                    KeyAlgorithm.Equals(other.KeyAlgorithm)
                ) && 
                (
                    CACertificateFileLocation == other.CACertificateFileLocation ||
                    CACertificateFileLocation != null &&
                    CACertificateFileLocation.Equals(other.CACertificateFileLocation)
                ) && 
                (
                    PublicKeyFileLocation == other.PublicKeyFileLocation ||
                    PublicKeyFileLocation != null &&
                    PublicKeyFileLocation.Equals(other.PublicKeyFileLocation)
                ) && 
                (
                    PrivateKeyFileLocation == other.PrivateKeyFileLocation ||
                    PrivateKeyFileLocation != null &&
                    PrivateKeyFileLocation.Equals(other.PrivateKeyFileLocation)
                ) && 
                (
                    VerifyHostName == other.VerifyHostName ||
                    VerifyHostName != null &&
                    VerifyHostName.Equals(other.VerifyHostName)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (KeyFormat != null)
                    hashCode = hashCode * 59 + KeyFormat.GetHashCode();
                    if (KeyAlgorithm != null)
                    hashCode = hashCode * 59 + KeyAlgorithm.GetHashCode();
                    if (CACertificateFileLocation != null)
                    hashCode = hashCode * 59 + CACertificateFileLocation.GetHashCode();
                    if (PublicKeyFileLocation != null)
                    hashCode = hashCode * 59 + PublicKeyFileLocation.GetHashCode();
                    if (PrivateKeyFileLocation != null)
                    hashCode = hashCode * 59 + PrivateKeyFileLocation.GetHashCode();
                    if (VerifyHostName != null)
                    hashCode = hashCode * 59 + VerifyHostName.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(MqttSecurityV1 left, MqttSecurityV1 right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(MqttSecurityV1 left, MqttSecurityV1 right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
